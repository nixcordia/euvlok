#! /usr/bin/env nix-shell
#! nix-shell -i bash -p jq curl wget unzip nix git p7zip
# shellcheck shell=bash

set -euo pipefail

DEFAULT_INPUT_FILE="modules/hm/gui/chromium/extensions_list.txt"
DEFAULT_OUTPUT_FILE="modules/hm/gui/chromium/extensions.nix"

INPUT_FILE="$DEFAULT_INPUT_FILE"
OUTPUT_FILE="$DEFAULT_OUTPUT_FILE"

usage() {
  echo "Usage: $0 [-i <input_file>] [-o <output_file>] [-h]"
  echo "  Generates a Nix file for Chromium extensions from a text list."
  echo ""
  echo "  Options:"
  echo "    -i <input_file>   Specify the input text file."
  echo "                      (default: ${DEFAULT_INPUT_FILE})"
  echo "    -o <output_file>  Specify the output Nix file."
  echo "                      (default: ${DEFAULT_OUTPUT_FILE})"
  echo "    -h                Display this help and exit."
}

# Parse command-line options
while getopts "hi:o:" opt; do
  case "$opt" in
    h)
      usage
      exit 0
      ;;
    i)
      INPUT_FILE="$OPTARG"
      ;;
    o)
      OUTPUT_FILE="$OPTARG"
      ;;
    \?)
      usage
      exit 1
      ;;
  esac
done

if [[ ! -f "$INPUT_FILE" ]]; then
  echo "Error: Input file not found at '${INPUT_FILE}'" >&2
  exit 1
fi

echo "Generating ${OUTPUT_FILE} from ${INPUT_FILE}..."

TMP_DIR=$(mktemp -d)
trap 'rm -rf -- "$TMP_DIR"' EXIT

TMP_OUTPUT_FILE="${TMP_DIR}/extensions.nix.tmp"

cat > "$TMP_OUTPUT_FILE" <<EOF
# This file is auto-generated by an update script
# DO NOT edit manually
{
  pkgs,
  config,
  lib,
  ...
}:
lib.flatten [
EOF

while read -r line || [[ -n "$line" ]]; do
  # Skip comments and empty lines
  if [[ "$line" =~ ^\s*# ]] || [[ -z "$line" ]]; then
    continue
  fi

  condition_str=""
  extension_part="$line"

  if [[ "$line" == *" if "* ]]; then
    extension_part="${line%% if *}" # Everything before " if "
    condition_str="${line#* if }"   # Everything after " if "
  fi

  # Parse the extension part into ID and url_part
  id=""
  url_part=""
  read -r id url_part <<<"$extension_part"

  # Sanitize potential carriage returns
  id=$(echo "$id" | tr -d '\r')
  url_part=$(echo "$url_part" | tr -d '\r')

  finalurl=""

  if [[ -z "$url_part" ]]; then
    echo "Processing Chrome Web Store ID: ${id}"
    x_param="id%3D${id}%26installsource%3Dondemand%26uc"
    URL="https://clients2.google.com/service/update2/crx?response=redirect&acceptformat=crx2,crx3&prodversion=133&x=${x_param}"
    finalurl=$(curl -w "%{url_effective}" -I -L -sS "${URL}" -o /dev/null)
  elif [[ "$url_part" == "bpc" ]]; then
    echo "Processing special case 'bpc' for ID: ${id}"
    bpc_repo="https://gitflic.ru/project/magnolia1234/bpc_uploads.git"
    commit=$(git ls-remote "$bpc_repo" HEAD | awk '{print $1}')
    if [[ -z "$commit" ]]; then
      echo "Error: Failed to get latest commit for bypass-paywalls-chrome." >&2
      exit 1
    fi
    echo "  -> Using BPC commit: ${commit}"
    finalurl="https://gitflic.ru/project/magnolia1234/bpc_uploads/blob/raw?file=bypass-paywalls-chrome-clean-latest.crx&inline=false&commit=${commit}"
  elif [[ "$url_part" =~ ^https?:// ]]; then
    echo "Processing direct URL for ID: ${id}"
    finalurl="$url_part"
  else
    echo "Warning: Unrecognized line format, skipping: '${line}'" >&2
    continue
  fi

  echo "  -> Downloading from: ${finalurl}"
  download_path="${TMP_DIR}/${id}.crx"
  wget --quiet --output-document="$download_path" "$finalurl"

  hex_hash=$(sha256sum "$download_path" | cut -d' ' -f1)
  hash=$(nix hash to-sri --type sha256 "$hex_hash")

  unzip_dir="${TMP_DIR}/unzipped-${id}"
  mkdir -p "$unzip_dir"

  if ! 7z x -o"$unzip_dir" "$download_path" >/dev/null; then
    echo "Error: Failed to extract archive for '${id}' using 7z." >&2; exit 1
  fi

  manifest_path="${unzip_dir}/manifest.json"
  if [[ ! -f "$manifest_path" ]]; then
    echo "Error: manifest.json not found for '${id}'." >&2; exit 1
  fi

  version=$(jq -r ".version" < "$manifest_path")
  if [[ "$version" == "null" ]]; then
      version=$(jq -r ".version_name" < "$manifest_path")
  fi
  if [[ "$version" == "null" ]]; then
      echo "Error: Could not extract version from manifest for '${id}'" >&2; exit 1
  fi

  rm -r "$unzip_dir"

  if [[ -n "$condition_str" ]]; then
    echo "  -> Generating conditional entry with condition: ${condition_str}"
    cat >> "$TMP_OUTPUT_FILE" <<EOF
  (lib.optionals (${condition_str}) [
    {
      id = "${id}";
      crxPath = pkgs.fetchurl {
        url = "${finalurl}";
        name = "${id}.crx";
        hash = "${hash}";
      };
      version = "${version}";
    }
  ])
EOF
  else
    cat >> "$TMP_OUTPUT_FILE" <<EOF
  {
    id = "${id}";
    crxPath = pkgs.fetchurl {
      url = "${finalurl}";
      name = "${id}.crx";
      hash = "${hash}";
    };
    version = "${version}";
  }
EOF
  fi

done < "$INPUT_FILE"

echo "]" >> "$TMP_OUTPUT_FILE"

mv "$TMP_OUTPUT_FILE" "$OUTPUT_FILE"

echo "Successfully generated and replaced ${OUTPUT_FILE}!"
