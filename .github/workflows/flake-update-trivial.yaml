name: Update Trivial Flake Inputs

on:
  workflow_dispatch:
  schedule:
    # Run every 2 days at midnight UTC
    - cron: "0 0 */2 * *"

permissions:
  contents: write

jobs:
  update-trivial-inputs:
    name: Update Trivial Inputs
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5.0.0
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@v20
        with:
          source-url: https://install.lix.systems/lix/lix-installer-x86_64-linux

      - name: Find and update trivial inputs
        id: find-inputs
        run: |
          set -euo pipefail
          export NIX_CONFIG="extra-experimental-features = nix-command flakes pipe-operator"

          # Check if flake.lock exists
          if [[ ! -f flake.lock ]]; then
            echo "::warning::flake.lock not found, skipping."
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Find all inputs ending in "-trivial" from flake.lock
          mapfile -t trivial_inputs < <(jq -r '.nodes.root.inputs | keys[] | select(test("-trivial$"))' flake.lock)

          if [[ ${#trivial_inputs[@]} -eq 0 ]]; then
            echo "::notice::No trivial inputs found to update."
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "::notice::Found ${#trivial_inputs[@]} trivial inputs: ${trivial_inputs[*]}"

          # Store old commit info before update
          declare -A old_commits repo_info
          for input in "${trivial_inputs[@]}"; do
            old_commits["$input"]=$(jq -r ".nodes[\"$input\"].locked.rev // \"unknown\"" flake.lock)
            repo_owner=$(jq -r ".nodes[\"$input\"].locked.owner // \"unknown\"" flake.lock)
            repo_name=$(jq -r ".nodes[\"$input\"].locked.repo // \"unknown\"" flake.lock)
            repo_info["$input"]="$repo_owner/$repo_name"
          done

          # Update all trivial inputs at once
          echo "::group::Updating trivial inputs"
          nix flake update "${trivial_inputs[@]}"
          echo "::endgroup::"

          # Check if anything _actually_ changed
          if git diff --quiet flake.lock; then
            echo "::notice::No changes detected in flake.lock after update."
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Start building up the message
          formatted_inputs=""
          for input in "${trivial_inputs[@]}"; do
            old_commit="${old_commits[$input]:0:7}"
            new_commit=$(jq -r ".nodes[\"$input\"].locked.rev // \"unknown\"" flake.lock)
            new_commit="${new_commit:0:7}"

            # Skip if no actual change
            [[ "$old_commit" == "$new_commit" ]] && continue

            repo="${repo_info[$input]}"
            if [[ "$repo" != "unknown/unknown" ]]; then
              github_url="https://github.com/$repo/compare/$old_commit...$new_commit"
              formatted_inputs+="- $input ($old_commit...$new_commit) - ($github_url)"$'\n'
            else
              formatted_inputs+="- $input ($old_commit...$new_commit)"$'\n'
            fi
          done

          echo "has_changes=true" >> $GITHUB_OUTPUT
          {
            echo "formatted_inputs<<EOF"
            echo "$formatted_inputs"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Commit and push changes
        if: steps.find-inputs.outputs.has_changes == 'true'
        run: |
          set -euo pipefail

          git config --local user.name "github-actions[bot]"
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add flake.lock
          
          COMMIT_TITLE="chore: update trivial flake inputs"
          COMMIT_BODY="${{ steps.find-inputs.outputs.formatted_inputs }}"
          
          git commit -m "$COMMIT_TITLE" -m "$COMMIT_BODY"

          MAX_ATTEMPTS=5
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if git push origin HEAD:${{ github.ref_name }}; then
              echo "::notice::Successfully pushed changes on attempt $i."
              exit 0
            fi

            if [[ $i -eq $MAX_ATTEMPTS ]]; then
              echo "::error::Failed to push after $MAX_ATTEMPTS attempts."
              exit 1
            fi

            wait_time=$((5 * i))
            echo "::warning::Push failed on attempt $i. Waiting ${wait_time}s and retrying after rebase..."
            sleep $wait_time
            
            git pull --rebase origin ${{ github.ref_name }}
          done
